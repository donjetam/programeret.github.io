{
    "version": "https://jsonfeed.org/version/1",
    "title": "Programerat",
    "home_page_url": "https://programeret.github.io/",
    "feed_url": "https://programeret.github.io/feed.json",
    "description": "Hajde te mesojm sot dicka.",
    "icon": "https://programeret.github.io/apple-touch-icon.png",
    "favicon": "https://programeret.github.io/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "programerat",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://programeret.github.io/2021/12/19/docker-test",
            "title": "Docker Test",
            "summary": null,
            "content_text": "### Test### Test",
            "content_html": "### Test### Test",
            "url": "https://programeret.github.io/2021/12/19/docker-test",
            
            
            
            
            
            "date_published": "2021-12-19T00:00:00+01:00",
            "date_modified": "2021-12-19T00:00:00+01:00",
            
                "author":  {
                "name": "programerat",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://programeret.github.io/2021/12/18/refactor-legacy-into-transaction",
            "title": "Refactor Legacy Into Transaction",
            "summary": null,
            "content_text": "Start using transaction in a non transaction legacy appSymfony Event VS Decorator VS Template MethodTemplate MethodThis method will force us each handler to have a method execute() but the downside would be that we need to add the MessageBusInterface for each handler.The good side is that we make sure everytime this handler is executed then it is going to be via Transaction.abstract class AbstractHandler {        public function handle(Command $command): void {        $this-&gt;pdo-&gt;startTransaction();        try {            $this-&gt;execute($command);            $this-&gt;pdo-&gt;commit();            $this-&gt;dispatchIntegrationEvents();        } catch (\\Exception $e) {            $this-&gt;pdo-&gt;rollBack();        }    }    abstract private function execute(Command $command): void;}class SomeHandler extends AbstractHandler {    private function execute(Command $command): void;}Symfony EventThis method is the same logic as Template Method, we need to dispatch an event at the end of the handler, this can be achieved via Decorator or TemplateMethod.abstract class AbstractHandler {        public function handle(Command $command): void {        $this-&gt;pdo-&gt;startTransaction();        try {            $this-&gt;execute($command);            $this-&gt;pdo-&gt;commit();            //dispatch symfony event            $this-&gt;dispatchEvent();        } catch (\\Exception $e) {            $this-&gt;pdo-&gt;rollBack();        }    }    abstract private function execute(Command $command): void;}class SomeHandler extends AbstractHandler {    private function execute(Command $command): void;}Decorator PatternThis is the cleanes way to implement the bus, we don’t need deps in the handlers/usecases.class DbTransactionBusDecorator {        //...deps    public function process(Command $command): void    {        $this-&gt;startDbTransaction();        try {            $this-&gt;commandBus-&gt;process($command);            $this-&gt;commitDbTransaction();        } catch (\\Throwable $ex) {            $this-&gt;rollbackDbTransaction();            throw $ex;        }        $this-&gt;dispatchIntegrationMessages(); // we dispatch here the integration events    }}Options that we haveHow to implement itWhat issues we will have###",
            "content_html": "<h1 id=\"start-using-transaction-in-a-non-transaction-legacy-app\">Start using transaction in a non transaction legacy app</h1><h3 id=\"symfony-event-vs-decorator-vs-template-method\">Symfony Event VS Decorator VS Template Method</h3><h3 id=\"template-method\">Template Method</h3><p>This method will force us each handler to have a method <code class=\"language-plaintext highlighter-rouge\">execute()</code> but the downside would be that we need to add the <code class=\"language-plaintext highlighter-rouge\">MessageBusInterface</code> for each handler.The good side is that we make sure everytime this handler is executed then it is going to be via Transaction.</p><pre><code class=\"language-PHP\">abstract class AbstractHandler {        public function handle(Command $command): void {        $this-&gt;pdo-&gt;startTransaction();        try {            $this-&gt;execute($command);            $this-&gt;pdo-&gt;commit();            $this-&gt;dispatchIntegrationEvents();        } catch (\\Exception $e) {            $this-&gt;pdo-&gt;rollBack();        }    }    abstract private function execute(Command $command): void;}class SomeHandler extends AbstractHandler {    private function execute(Command $command): void;}</code></pre><h3 id=\"symfony-event\">Symfony Event</h3><p>This method is the same logic as Template Method, we need to dispatch an event at the end of the handler, this can be achieved via Decorator or TemplateMethod.</p><pre><code class=\"language-PHP\">abstract class AbstractHandler {        public function handle(Command $command): void {        $this-&gt;pdo-&gt;startTransaction();        try {            $this-&gt;execute($command);            $this-&gt;pdo-&gt;commit();            //dispatch symfony event            $this-&gt;dispatchEvent();        } catch (\\Exception $e) {            $this-&gt;pdo-&gt;rollBack();        }    }    abstract private function execute(Command $command): void;}class SomeHandler extends AbstractHandler {    private function execute(Command $command): void;}</code></pre><h3 id=\"decorator-pattern\">Decorator Pattern</h3><p>This is the cleanes way to implement the bus, we don’t need deps in the handlers/usecases.</p><pre><code class=\"language-PHP\">class DbTransactionBusDecorator {        //...deps    public function process(Command $command): void    {        $this-&gt;startDbTransaction();        try {            $this-&gt;commandBus-&gt;process($command);            $this-&gt;commitDbTransaction();        } catch (\\Throwable $ex) {            $this-&gt;rollbackDbTransaction();            throw $ex;        }        $this-&gt;dispatchIntegrationMessages(); // we dispatch here the integration events    }}</code></pre><h3 id=\"options-that-we-have\">Options that we have</h3><h3 id=\"how-to-implement-it\">How to implement it</h3><h3 id=\"what-issues-we-will-have\">What issues we will have</h3><p>###</p>",
            "url": "https://programeret.github.io/2021/12/18/refactor-legacy-into-transaction",
            
            
            
            
            
            "date_published": "2021-12-18T00:00:00+01:00",
            "date_modified": "2021-12-18T00:00:00+01:00",
            
                "author":  {
                "name": "programerat",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://programeret.github.io/2021/12/15/rregullat-e-shkrimit-ne-shqipe-rreth-programimit",
            "title": "Fjalori i perdorur në shqip rreth artikujve në IT.",
            "summary": null,
            "content_text": "Përderisa mungesa e fjalëve në shqip rreth teknologjisë është shumë e madhe, zgjidhja që do të përdoret në shpjegimin emetodave dhe principeve të ndryshme në programim do të bëhet si në vijim.   Të gjitha emrat dhe shkurtesat nëgjuhën angleze do të barten direkt në gjuhën shqipe, edhe pse disa nga shkronjat nuk egzistojnë në alfabetin tonë. Arsyet janë këto:  Së pari të kemi një burim ku ti referohemi komunitetit tonë, ti qasemi problemeve dhe të i zgjidhim së bashku.  Nëse mësoni diçka të re në gjuhën shqipe, ta keni më të lehtë që të gjeni referenca në gjuhën angleze, përveç atyrefjalëve që vetëm egzistojnë dhe janë të njohura.  Komunikim i rrjedhshëm me të gjithë programerët.  Të krijohet një lidhje në gjuhën shqipe me atë angleze me termet që perdoren në IT.  Të mund të kapim një bisedë rreth një Principle apo një Pattern pa u brengosur se mos dikush po na e gjykon gjuhën.  Që të mos e izolojmë vetën duke u munduar që të i përkthejmë fjalët ndersa fjalë të reja dalin çdo ditë në Anglisht.  P.SH            Anglisht      Shqip (Shqiptimi)      Shqiptimi                  Class      Class      Klas              Factory Method      Factory Method      Faktory Method              Algorithm      Algoritem      Algoritem              Chain of command      Chain of command      Qain of Komand              YANKI      YANKI      Janki              OOP      OOP      OOPE              DDD      DDD      Di`Di`Di              Domain Driven Design      Dizajn i orientuar në Domain      ~              Architecture      Arkitektura      ~              Software Architecture      Software Architecture      Akitekture Softuerike              Framework      Framework      Frameuork              KISS      KISS      Kis              Mental Overload      Mental Overload      Mental Overload              SOLID      SOLID      Solid              Software Development      Software Development      Softuer Development              Interface      Interface      Interfejs      Këto janë disa nga shembujt e fjalëve se si do të perdoren në artikuj.   Pse duhet të perdorim këto fjalë?  Thjeshtë, nëse i perdorim emertimin e njejtë si në Anglisht atëher gjetja e definicioneve në anglisht do të bëhet më elehtë në të ardhmen.  Ashtu edhe kur flasim në shqip rreth teknologjisë i perdorim emrat dhe shkurtesat ne gjuhë angleze, prandaj të paktëntë jemi konsistent që të gjithë ti perdorim fjalët e njeta edhe pse nuk janë fjalë të që egzistojnë në fjalor.  Nuk na izolon por do të na e mundëson që të kapemi për termet angleze, gje që e forcon lidhjen me anglishten. Un besoj që kjo do të ndihmojë ose kontribojë në nismën për iniciativën për të pasur një fjalor të përditsuar.Komentoni mendimin tuaj.",
            "content_html": "<p>Përderisa mungesa e fjalëve në shqip rreth teknologjisë është shumë e madhe, zgjidhja që do të përdoret në shpjegimin emetodave dhe principeve të ndryshme në programim do të bëhet si në vijim.   <br /></p><p>Të gjitha emrat dhe shkurtesat nëgjuhën angleze do të barten direkt në gjuhën shqipe, edhe pse disa nga shkronjat nuk egzistojnë në alfabetin tonë. <br /></p><p><strong>Arsyet janë këto:</strong></p><ol>  <li>Së pari të kemi një burim ku ti referohemi komunitetit tonë, ti qasemi problemeve dhe të i zgjidhim së bashku.</li>  <li>Nëse mësoni diçka të re në gjuhën shqipe, ta keni më të lehtë që të gjeni referenca në gjuhën angleze, përveç atyrefjalëve që vetëm egzistojnë dhe janë të njohura.</li>  <li>Komunikim i rrjedhshëm me të gjithë programerët.</li>  <li>Të krijohet një lidhje në gjuhën shqipe me atë angleze me termet që perdoren në IT.</li>  <li>Të mund të kapim një bisedë rreth një Principle apo një Pattern pa u brengosur se mos dikush po na e gjykon gjuhën.</li>  <li>Që të mos e izolojmë vetën duke u munduar që të i përkthejmë fjalët ndersa fjalë të reja dalin çdo ditë në Anglisht.  P.SH</li></ol><table>  <thead>    <tr>      <th style=\"text-align: center\">Anglisht</th>      <th style=\"text-align: center\">Shqip (Shqiptimi)</th>      <th style=\"text-align: center\">Shqiptimi</th>    </tr>  </thead>  <tbody>    <tr>      <td style=\"text-align: center\">Class</td>      <td style=\"text-align: center\">Class</td>      <td style=\"text-align: center\">Klas</td>    </tr>    <tr>      <td style=\"text-align: center\">Factory Method</td>      <td style=\"text-align: center\">Factory Method</td>      <td style=\"text-align: center\">Faktory Method</td>    </tr>    <tr>      <td style=\"text-align: center\">Algorithm</td>      <td style=\"text-align: center\">Algoritem</td>      <td style=\"text-align: center\">Algoritem</td>    </tr>    <tr>      <td style=\"text-align: center\">Chain of command</td>      <td style=\"text-align: center\">Chain of command</td>      <td style=\"text-align: center\">Qain of Komand</td>    </tr>    <tr>      <td style=\"text-align: center\">YANKI</td>      <td style=\"text-align: center\">YANKI</td>      <td style=\"text-align: center\">Janki</td>    </tr>    <tr>      <td style=\"text-align: center\">OOP</td>      <td style=\"text-align: center\">OOP</td>      <td style=\"text-align: center\">OOPE</td>    </tr>    <tr>      <td style=\"text-align: center\">DDD</td>      <td style=\"text-align: center\">DDD</td>      <td style=\"text-align: center\">Di`Di`Di</td>    </tr>    <tr>      <td style=\"text-align: center\">Domain Driven Design</td>      <td style=\"text-align: center\">Dizajn i orientuar në Domain</td>      <td style=\"text-align: center\">~</td>    </tr>    <tr>      <td style=\"text-align: center\">Architecture</td>      <td style=\"text-align: center\">Arkitektura</td>      <td style=\"text-align: center\">~</td>    </tr>    <tr>      <td style=\"text-align: center\">Software Architecture</td>      <td style=\"text-align: center\">Software Architecture</td>      <td style=\"text-align: center\">Akitekture Softuerike</td>    </tr>    <tr>      <td style=\"text-align: center\">Framework</td>      <td style=\"text-align: center\">Framework</td>      <td style=\"text-align: center\">Frameuork</td>    </tr>    <tr>      <td style=\"text-align: center\">KISS</td>      <td style=\"text-align: center\">KISS</td>      <td style=\"text-align: center\">Kis</td>    </tr>    <tr>      <td style=\"text-align: center\">Mental Overload</td>      <td style=\"text-align: center\">Mental Overload</td>      <td style=\"text-align: center\">Mental Overload</td>    </tr>    <tr>      <td style=\"text-align: center\">SOLID</td>      <td style=\"text-align: center\">SOLID</td>      <td style=\"text-align: center\">Solid</td>    </tr>    <tr>      <td style=\"text-align: center\">Software Development</td>      <td style=\"text-align: center\">Software Development</td>      <td style=\"text-align: center\">Softuer Development</td>    </tr>    <tr>      <td style=\"text-align: center\">Interface</td>      <td style=\"text-align: center\">Interface</td>      <td style=\"text-align: center\">Interfejs</td>    </tr>  </tbody></table><p>Këto janë disa nga shembujt e fjalëve se si do të perdoren në artikuj.   <br /></p><p><strong>Pse duhet të perdorim këto fjalë?</strong></p><ul>  <li>Thjeshtë, nëse i perdorim emertimin e njejtë si në Anglisht atëher gjetja e definicioneve në anglisht do të bëhet më elehtë në të ardhmen.</li>  <li>Ashtu edhe kur flasim në shqip rreth teknologjisë i perdorim emrat dhe shkurtesat ne gjuhë angleze, prandaj të paktëntë jemi konsistent që të gjithë ti perdorim fjalët e njeta edhe pse nuk janë fjalë të që egzistojnë në fjalor.</li>  <li>Nuk na izolon por do të na e mundëson që të kapemi për termet angleze, gje që e forcon lidhjen me anglishten.</li></ul><p> <br />Un besoj që kjo do të ndihmojë ose kontribojë në nismën për iniciativën për të pasur një fjalor të përditsuar.</p><p>Komentoni mendimin tuaj.</p>",
            "url": "https://programeret.github.io/2021/12/15/rregullat-e-shkrimit-ne-shqipe-rreth-programimit",
            
            
            
            
            
            "date_published": "2021-12-15T00:00:00+01:00",
            "date_modified": "2021-12-15T00:00:00+01:00",
            
                "author":  {
                "name": "programerat",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://programeret.github.io/2021/12/15/dp-chain-of-responsibility",
            "title": "Design Patterns - Chain of Responsibility (Shqip)",
            "summary": null,
            "content_text": "Chain of ResponsibilityGjithashtu njihet si: CoR, Chain of CommandPErshkrimi ShembulliPrincipet qe supportonNje tip rreth programmmingShembull konkret nga jeta realeNjë veçori e reNjë shembull se si nuk duhet të zbatohet.UML Modeli i strategjiseImplementimi korrent i dizajnitMbyllja",
            "content_html": "<h3 id=\"chain-of-responsibility\">Chain of Responsibility</h3><p>Gjithashtu njihet si: CoR, Chain of Command</p><p>PErshkrimi Shembulli</p><p>Principet qe supporton</p><p>Nje tip rreth programmming</p><h3 id=\"shembull-konkret-nga-jeta-reale\">Shembull konkret nga jeta reale</h3><h3 id=\"një-veçori-e-re\">Një veçori e re</h3><h3 id=\"një-shembull-se-si-nuk-duhet-të-zbatohet\">Një shembull se si nuk duhet të zbatohet.</h3><h3 id=\"uml-modeli-i-strategjise\">UML Modeli i strategjise</h3><h3 id=\"implementimi-korrent-i-dizajnit\">Implementimi korrent i dizajnit</h3><h3 id=\"mbyllja\">Mbyllja</h3>",
            "url": "https://programeret.github.io/2021/12/15/dp-chain-of-responsibility",
            
            
            
            
            
            "date_published": "2021-12-15T00:00:00+01:00",
            "date_modified": "2021-12-15T00:00:00+01:00",
            
                "author":  {
                "name": "programerat",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://programeret.github.io/2021/12/13/modelet-e-dizajnimit-strategjia",
            "title": "Paternet e dizajnimit - Paterni Strategji",
            "summary": "Paterni strategji bën pjesë në kategorinë e kontrollit të sjelljes së objekteve duke mundësuar më shumë fleksibilitet në komunikimin në mes objekteve.",
            "content_text": "Paterni strategji mundësonë që ti izolojmë algoritmet në klasa të ndryshme, dhe mundëson zëvendesimin e algoritmeve pa pasur nevojë qe kodi të ndryshohet. Pra paterni strategji na mundësonë që të shtojmë klasa të tjera që implementojnë algoritme të ndryshme por janë të tipit të njëjtë. Gjithashtu kjo e mbështetë  principin e parë  Hapur për zgjerim e mbyllur për ndryshime. E mbështetë  edhe principin e pestë në SOLID ku gjithçka varet në kontratë dhe jo në zbatim. Prandaj ky patern na mundësonë që të kemi shumë zbatime të bazuara  në një kontratë.   Mos harroni KISS para çdo gjëje tjetër.Shembull konkret nga jeta realeNëse për shembull duam të udhëtojmë nga qyteti  A në qytetin B, ne duhet ta dimë se si të arrijmë më shpejtë në destinacion. Supozojmë që ne e  kemi ndërtuar një aplikacion i cili e llogaritë rrugën më të shpejtë me makinë.Implementimi në kod do të duket si më poshtë:Një veçori e reTani na kërkohet të shtojmë një mënyrë të re transporti. Si do të shtonim një mënyrë të re transporti pa shkelur rregullat SOLID?Një shembull se si nuk duhet të zbatohet.Në shembullin e mëposhtëm shohim se si rregulli i parë i principeve SOLID është thyer, Principi i një përgjegjësie. Gjithashtu thyen principin e dytë e mbyllur për ndryshime, nëse metoda e njërit prej transporteve ndryshon atëhere edhe  kjo klasë duhet të ndryshojë.Kjo klasë,  në jetën reale do të ishte klasa më e madhe në projekt  nëse do të punonim në një aplikacion si në shembullin më lartë.UML Modeli i strategjiseNë diagram e shohim se e kemi një kontratë Transport, pastaj, çdo klasë me zbatime të ndryshme në bazë të kontratës. Klientit nuk i intereson sesi zbatohet algoritmi sepse ai varet në kontratë dhe kjo e mbështetë principin e pestë  Inversionin i varësisë.Implementimi korrent i dizajnitPjesa me switch mund të bartet në një factory ku në bazë të inputit e krijon klasën specifike. P.SHKëtë pjesë mund ta shpjegoj kur të shkruaj për paternin Factory më në detaje.MbylljaGjithmonë kur shkruajmë kod duhet të përpiqemi të lidhim problemin me jetën e përditshme, nëse nuk është e mundur me biznesin.Zbatimi i principeve dhe modeleve bëhet më i lehtë kur e kuptoni problemin. Për të parë nëse e kuptoni problemin atëherë  provoni t’ia shpjegoni dikujt ose përdorni metodën Rubber Duck.   Siç thotë shprehja, nëse mund t’ia shpjegoni dikujt me fjalë të thjeshta, atëherë e kuptoni problemin.  Rubber duck është një metodë shumë e popullarizuar që programuesit e përdorin sepse shpesh nuk kemi pyetje pasi që mendojmë se gjithçka është e qartë, ndërsa nëse përpiqemi ta shpjegojmë atë atëherë e shohim që nuk e kemi kuptuar në të vërtetë.Në vazhdim do të postoj për modele të tjera por edhe për metoda të ndryshme që përdorin programuesit. Kodim të këndshëm. &lt;3 &lt;/&gt;",
            "content_html": "<p>Paterni strategji mundësonë që ti izolojmë algoritmet në klasa të ndryshme, dhe mundëson zëvendesimin e algoritmeve pa pasur nevojë qe kodi të ndryshohet. Pra paterni strategji na mundësonë që të shtojmë klasa të tjera që implementojnë algoritme të ndryshme por janë të tipit të njëjtë.<br /> </p><p>Gjithashtu kjo e mbështetë  principin e parë <a href=\"https://programerat.github.io/2021/SOLID-principet-dhe-si-ti-aplikoni-ne-kod/#Principi%20i%20dytë%20-%20E%20hapur%20për%20zgjatje,%20e%20mbyllur%20për%20ndryshime.\"> Hapur për zgjerim e mbyllur për ndryshime.</a> E mbështetë  edhe principin e pestë në SOLID ku gjithçka varet në kontratë dhe jo në zbatim. Prandaj ky patern na mundësonë që të kemi shumë zbatime të bazuara  në një kontratë.<br /> </p><blockquote>  <p>Mos harroni <a href=\"https://en.wikipedia.org/wiki/KISS_principle\">KISS</a> para çdo gjëje tjetër.</p></blockquote><h3 id=\"shembull-konkret-nga-jeta-reale\">Shembull konkret nga jeta reale</h3><p>Nëse për shembull duam të udhëtojmë nga qyteti  A në qytetin B, ne duhet ta dimë se si të arrijmë më shpejtë në destinacion. Supozojmë që ne e  kemi ndërtuar një aplikacion i cili e llogaritë rrugën më të shpejtë me makinë.</p><p>Implementimi në kod do të duket si më poshtë:<script src=\"https://gist.github.com/Diarselimi/bfd539de510e269233dee8cdf5987403.js\"></script></p><h3 id=\"një-veçori-e-re\">Një veçori e re</h3><p>Tani na kërkohet të shtojmë një mënyrë të re transporti. Si do të shtonim një mënyrë të re transporti pa shkelur rregullat SOLID?</p><h3 id=\"një-shembull-se-si-nuk-duhet-të-zbatohet\">Një shembull se si nuk duhet të zbatohet.</h3><p>Në shembullin e mëposhtëm shohim se si rregulli i parë i principeve SOLID është thyer, <a href=\"https://programerat.github.io/2021/SOLID-principet-dhe-si-ti-aplikoni-ne-kod/#Principi%20i%20par%C3%AB%20-%20Nj%C3%AB%20klas%C3%AB,%20nj%C3%AB%20p%C3%ABrgjegj%C3%ABsi\">Principi i një përgjegjësie</a>. <a href=\"https://programerat.github.io/2021/SOLID-principet-dhe-si-ti-aplikoni-ne-kod/#Principi%20i%20dyt%C3%AB%20-%20E%20hapur%20p%C3%ABr%20zgjatje,%20e%20mbyllur%20p%C3%ABr%20ndryshime.\">Gjithashtu thyen principin e dytë e mbyllur për ndryshime</a>, nëse metoda e njërit prej transporteve ndryshon atëhere edhe  kjo klasë duhet të ndryshojë.<script src=\"https://gist.github.com/Diarselimi/ab34e500d821307baf0bf48827f92039.js\"></script>Kjo klasë,  në jetën reale do të ishte klasa më e madhe në projekt  nëse do të punonim në një aplikacion si në shembullin më lartë.</p><h3 id=\"uml-modeli-i-strategjise\">UML Modeli i strategjise</h3><p><img src=\"/assets/diagrams/transporti.png\" alt=\"uml diagrami\" />Në diagram e shohim se e kemi një kontratë <code class=\"language-plaintext highlighter-rouge\">Transport</code>, pastaj, çdo klasë me zbatime të ndryshme në bazë të kontratës. Klientit nuk i intereson sesi zbatohet algoritmi sepse ai varet në kontratë dhe kjo e mbështetë principin e pestë <a href=\"https://programerat.github.io/2021/SOLID-principet-dhe-si-ti-aplikoni-ne-kod/#Principi%20i%20pest%C3%AB%20-%20Inversioni%20i%20var%C3%ABsis%C3%AB\"> Inversionin i varësisë</a>.</p><h3 id=\"implementimi-korrent-i-dizajnit\">Implementimi korrent i dizajnit</h3><script src=\"https://gist.github.com/Diarselimi/d5eafb20f04cea71f0fe7b28b81d8b67.js\"></script><p>Pjesa me <code class=\"language-plaintext highlighter-rouge\">switch</code> mund të bartet në një factory ku në bazë të inputit e krijon klasën specifike. P.SH<script src=\"https://gist.github.com/Diarselimi/a3191d3e3b6ff9bf3ba3e31331bf15e5.js\"></script>Këtë pjesë mund ta shpjegoj kur të shkruaj për paternin Factory më në detaje.</p><h3 id=\"mbyllja\">Mbyllja</h3><p>Gjithmonë kur shkruajmë kod duhet të përpiqemi të lidhim problemin me jetën e përditshme, nëse nuk është e mundur me biznesin.Zbatimi i principeve dhe modeleve bëhet më i lehtë kur e kuptoni problemin. Për të parë nëse e kuptoni problemin atëherë  provoni t’ia shpjegoni dikujt ose përdorni metodën <a href=\"https://en.wikipedia.org/wiki/Rubber_duck_debugging\">Rubber Duck.</a> </p><blockquote>  <p>Siç thotë shprehja, nëse mund t’ia shpjegoni dikujt me fjalë të thjeshta, atëherë e kuptoni problemin.</p></blockquote><p>  </p><p>Rubber duck është një metodë shumë e popullarizuar që programuesit e përdorin sepse shpesh nuk kemi pyetje pasi që mendojmë se gjithçka është e qartë, ndërsa nëse përpiqemi ta shpjegojmë atë atëherë e shohim që nuk e kemi kuptuar në të vërtetë.<br />Në vazhdim do të postoj për modele të tjera por edhe për metoda të ndryshme që përdorin programuesit.<br /> </p><p>Kodim të këndshëm. <code class=\"language-plaintext highlighter-rouge\">&lt;3 &lt;/&gt;</code></p>",
            "url": "https://programeret.github.io/2021/12/13/modelet-e-dizajnimit-strategjia",
            
            
            
            "tags": ["OO,","Design","Patterns,","PHP"],
            
            "date_published": "2021-12-13T18:35:00+01:00",
            "date_modified": "2021-12-13T18:35:00+01:00",
            
                "author": "Diar Selimi"
            
        },
    
        {
            "id": "https://programeret.github.io/2021/11/17/solid-principet-dhe-si-ti-aplikoni-ne-kod",
            "title": "Principet S.O.L.I.D dhe si të aplikojmë ato në kod",
            "summary": "Krijoni një bazë të fortë në programim duke mësuar SOLID principet.",
            "content_text": "E pyeta një të afërm timin pse duhet ti mësojmë SOLID principet?Ja si përgjigjet ai…  Dallimi në mes amaterëve dhe profesinistëve që kërkohen nga cdo kompani, perfshir: Tesla, Google, Apple, SpaceX etj gjendet tek aplikimi i principeve të ndryshme.Pasi të lexoni këtë artikull, si dhe të analizoni shembujt që janë në këtë artikull, ju do të kuptoni principet SOLID dhe do të jeni të gatshëm ti aplikoni ato.Çdo kompani në Gjermani që do të aplikoni si zhvillues softveri, do të ju parashtrojn pytje në intervistë në lidhje me principet SOLID.Principet SOLID në OO programim do të ndihmojnë shumë në karrierën tuaj si programer.Do të kesh një bazë stabile për të ecur përpara, pa pasur parasysh produktin që ti e ndërton.Prezantimi i problemitPara se të fillojm, do ta prezantoj problemin që do të punoj gjatë të gjithë shembujve që i marr.ProblemiTë marrim shembull një klient i juaj do të ju kërkoj me zhvillu një aplikacion. Ky aplikacion do ti digjitalizoj porosit në restaurantin e tij Villa Natyra që vetëm bën piza dhe hamburgera.Ne si programera të mirë që jem ja ndërtojm aplikacionin, tash ai po e përdor dhe është i kënaqur.Në rregull, masi e kem ndërtu produktin tash hajde të flasim për principet.Principi i parë - Një klasë, një përgjegjësi  Një klasë duhet të këtë vetëm një përgjegjësi dhe një arsyje të ndryshoj.Një shembull ku ky princip nuk respektohetclass Hamburgeri{   private string $kategoria;   private array $shtesat;   private string $llojiIMishit;    public function __constructor(string $llojiIMishit, array $shtesat)   {       $this-&gt;kategoria = $this-&gt;percaktoKategorine($llojiIMishit);       $this-&gt;shtesat = $shtesat;       $this-&gt;llojiIMishit = $llojiIMishit;   }    private function përcaktoKategorine(string $llojiIMishit): string   {       if (in_array($llojiIMishit, ['file_pule', 'mish_lope'])) {           return 'zgare';       }        return 'furre';   }    public function llogaritShumen(): double   {       double $shuma = 0;       foreach($this-&gt;shtesat as $shtesa) {           $shuma += $shtesa-&gt;merrQmimin();       }        return $this-&gt;llojiIMishit + $shuma;   }    public function ruajFakturen(): void   {       //ktu ruhet faktura në databazë   }}Nëse e kemi një klasë vetëm për hamburgerin edhe kjo klasë pranon shtesa sikur sallatë, domate etj.Gjithashtu e përcaktojmë kategorinë mbrenda klasës, i ruajm të dhënat në databazë dhe e kalkulojmë shumën.Atëher kjo klasë do të ndryshoj sa herë që mënyra e ruajtjës në databazë ose mënyra e kalkulimit ose mënyra e përcaktimit të kategorise ndryshojnë.interface Ushqim {} class Hamburgeri implements Ushqim{   private const KATEGORIA = 'furre';   public array $shtesat;   public string $llojiIMishit;   public double $shuma;    public function __constructor(string $llojiIMishit, array $shtesat)   {       $this-&gt;kategoria = $this-&gt;percaktoKategorine($llojiIMishit);       $this-&gt;shtesat = $shtesat;       $this-&gt;llojiIMishit = $llojiIMishit;   }    public function merrKategorine(): string   {       return self::KATEGORIA;   }} class KalkulatoriUshqimit{   public function __constructor(Ushqim $ushqimi){}    public function merrShumen(): double   {       return 0.0; //ktu  kalkulohet shuma.   }} class RuajtjaFaktures{   public function ruaj(Faktura $faktura): void   {       $this-&gt;save($faktura);   }} class Faktura{   public function __constructor(Ushqim $ushqimi, double $shuma)}Kurse këtu siç edhe shihet që i kemi ndarë klasat me përgjegjësi të ndryshme, sa herë që kalkulimi i çmimit ndryshon atëher klasa KalkulatoriUshqimit po ashtu ndryshon. Nëse vendosim ta ndrrojmë mënyrën se si i ruajmë të dhënat atëher klasa RuajtjaFaktures ndryshon.Principi i dytë - E hapur për zgjatje, e mbyllur për ndryshime.  Një klasë duhet të jete e mbyllur për ndryshime ndërsa e hapur për zgjatje.Ta marrim shembull klasën që i bën kalkulimet KalkulatoriUshqimit dhe ta shohim si do të ndryshoj nëse një kërkes e re na vjen, shembull “Po me duhet që për studente çmimi final të dal 20% më lirë”Tash na si programera pa dijeni për këtë princip “E mbyllur për ndryshime” do ta bëjme një ndryshim si në vijiminterface Ushqim {} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           $shuma += $shtesa-&gt;merrShumen();       }        return $shuma;   }    public function merrShumenPerStudente(Ushqim $ushqim): double   {       $shuma = $this-&gt;merrShumen($ushqim);        return $shuma - ($shuma * 0.2);   } }Nëse bëjme diçka si kjo atëher së pari klasa ka jo një arsye por dy për të ndryshuar, që e then edhe principin e parë, shohim që po e kalkulon shumën e ushqimit dhe zbritjen për studenta. Tash nëse ndryshon mënyra e kalkulimit të ushqimit ose përqindja për studenta, atëher kjo klasë duhet të modifikohet.Nëse e konsiderojm Principin e parë, zbritja duhet të jete në një klas ndamas dhe në bazë të principit të dytë, klasa e re mund ta përdor klasën që kalkulon por nuk duhet ta ndryshoj atë.Si rezultat kemi bërë një ndryshim si në vijim.interface Ushqim {} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           $shuma += $shtesa-&gt;merrShumen();       }        return $shuma;   } } class KalkulatoriUshqimitPerStudente extends KalkulatoriUshqimit{   private const ZBRITJE_NE_PERQINDJE = 0.2;    public function merrShumen(Ushqim $ushqimi): double   {       return $this-&gt;zbritShumen(parent::merrShumen($ushqimi));   }    private function zbritShumen(double $shuma): double   {       return $shuma - ($shuma * self::ZBRITJE_NE_PERQINDJE);   } }Siç edhe pe shihni i kemi ndarë përgjegjsit në klasa të ndryshme, tash nëse mënyra e kalkulimit të ushqimit ndryshon atëher do të ndryshoj vetem KalkulatoriUshqimit dhe nëse zbritja për student ndryshon atëher do të ndryshoj vetëm klasa KalkulatoriUshqimitPerStudente.Principi i tretë - Zëvendesimi Liskov  Ky princip thot që nëse funksioni f(x) punon me objektet e tipit T. Atëher funksioni f(y) duhet të punoj me objektet y të tipit S ku S është nën tip i T.Ndoshta shembulli që e then këtë princip do ta lehtsoj kuptimin e ketij principi.interface Ushqim {} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           $shuma += $shtesa-&gt;merrShumen();       }        return $shuma;   } } class KalkulatoriUshqimitPerStudente extends KalkulatoriUshqimit{   private const ZBRITJE_NE_PERQINDJE = 0.2;    public function merrShumen(Ushqim $ushqimi): double   {       return $this-&gt;zbritShumen(parent::merrShumen($ushqimi));   }    private function zbritShumen(double $shuma): double   {       return $shuma - ($shuma * self::ZBRITJE_NE_PERQINDJE);   } }Kjo pjese e kodit është pjesë e principit të dytë ku e kem zgjatur klasën KalkulatoriUshqimit, me këtë ndryshim të metodës merrShumen e kemi thyer rregullin e principit të tretë.Nëse i referohemi definicionit i bjen që e njëjta metodë nuk duhet të kthen vlera të ndryshme edhe pse është klasë tjeter.Do ta rregullojme këtë klasë si në vijim.interface Ushqim {} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           $shuma += $shtesa-&gt;merrShumen();       }        return $shuma;   } } class KalkulatoriUshqimitPerStudente extends KalkulatoriUshqimit{   private const ZBRITJE_NE_PERQINDJE = 0.2;    public function merrShumenEZbritur(): double   {       $this-&gt;zbritShumen($this-&gt;merrShumen());   }    private function zbritShumen(double $shuma): double   {       return $shuma - ($shuma * self::ZBRITJE_NE_PERQINDJE);   } }Në vend që ta modifikojm metodën e klasës origjinale, do ta përdorim atë në klasën për studente dhe do të shtojmë metoda në klasën për studente.Principi i katert - Ndarja e kontratave  Një klasë nuk duhet ta implementoj një metodë që nuk i nëvojitet.Shembull shtesat e ushqimeve, siq e kemi parë me lartë secila shtesë e ka çmimin e vet, po çka nëse kemi shtesa që nuk kushtojn?Shembull:interface Ushqim {}interface Shtesa {   public function merrShumen(): double;} class Sallate implements Shtesa {   public const QMIMI = 0.50;    public function merrShumen() {       return self::QMIMI;   }} class BbqSos implements Shtesa {   public const QMIMI = 0.20;    public function merrShumen() {       return self::QMIMI;   }} class Ketchup implements Shtesa {   public const QMIMI = 0.00;    public function merrShumen() {       return self::QMIMI;   }} class Hamburger implements Ushqim {   private const QMIMI = 2.00;    public function merrQmimin():double   {       return self::QMIMI;   }}Siç e shohim në shembullin më lart, shtesa  Ketchup edhe pse është falas  duhet ta implementoj metodën merrShumen dhe kjo nuk e respekton principin e katërt, një klasë nuk duhet ta implementoj një metodë që nuk i nevojitet.Kështu duhet  ta ndryshojm kodin që ta respektojme principin e katërt.interface Ushqim {}interface Shtesa {   public function merrSasine(): int;}interface ShtesaMePages implements Shtesa {   public function merrShumen(): double;} class Sallate implements ShtesaMePages {   public const QMIMI = 0.50;    public function merrShumen() {       return self::QMIMI;   }} class Ketchup implements Shtesa {   private int $sasia = 1;    public function merrSasine(): int   {       return $this-&gt;sasia;   }} class Hamburger implements Ushqim {   private const QMIMI = 2.00;    public function merrQmimin():double   {       return self::QMIMI;   }} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           if ($shtesa instanceof ShtesaMePages) {               $shuma += $shtesa-&gt;merrShumen();             }       }        return $shuma;   } }Ky është një shembull ku ndahet kontrata për shtesat me  çmime dhe ato pa  çmime, për arsye që shtesat pa çmime nuk kan nevoj ta implementojnë metodën merrQmimin().Principi i pestë - Inversioni i varësisë  Një klasë që kryen një punë asnjëherë nuk duhet të varet në mjetin që e përdor por në kontratë.Një shembull do të ishte ta ruajm fakturen në MySQL databazë si në shembullin në vijim.E mbani mend si klasa RuajtjaFaktures varet direkt në klasën Databaza që është edhe implementimi mbrenda.Tani klasa RuajtjaFaktures e then principin e parë sepse nëse e ndryshojme databazën  atëher duhet ta ndryshojm edhe klasën RuajtjaFaktures.class Databaza{   public function ruaj(Faktura $faktura): void   {       $sql = \"INSERT into FAKTURAT (val1, val2, val3) VALUES (1,2,3);\"       $this-&gt;db-&gt;executeSql($sql);   }} class RuajtjaFaktures{   public function __constructor(Databaza $databaza){}    public function ruaj(Faktura $faktura): void   {       $this-&gt;databaza-&gt;ruaj($faktura);   }} class Faktura{   public function __constructor(Ushqim $ushqimi, double $shuma)}Një shembull  që do ta respektonte principin e pestë do të ishte si në vijim.interface Databaza {   public function ruaj(Faktura $faktura): void;} class HapsiraRuajtjesSeFakturave implements Databaza{   public function ruaj(Faktura $faktura): void   {       $sql = \"INSERT into FAKTURAT (val1, val2, val3) VALUES (1,2,3);\"       $this-&gt;db-&gt;executeSql($sql);   }} class RuajtjaFaktures{   public function __constructor(Databaza $databaza){}    public function ruaj(Faktura $faktura): void   {       $this-&gt;databaza-&gt;ruaj($faktura);   }}   class Faktura{   public function __constructor(Ushqim $ushqimi, double $shuma)}Ne këtë shembull e shohim që tani kemi një kontratë Databaza dhe një klasë ku gjendet implementimi i ruajtjes së fakturave HapsiraRuajtjesSeFakturave, tash nëse vendosim ta ndryshojm databazën në MongoDB, NoSQL ose çkado qoft nuk kemi nevoj ta ndryshojm klasën RuajtjaFaktures sepse ajo varet në kontrat e jo në implementim.Finalizimi dhe hapat e tjerëKëto janë pra pesë principet në OO të cilat shikohen në secilën intervistë se sa mirë i ke kuptuar dhe a din si ti përdorni ato.Hapat e radhës janë: Që të provosh ti aplikosh këto principe duhet startuar një projekt të vogël ose edhe në punën ku punon.Kur e shikon një kod në fillim të merr kohe ti shikosh të gjitha principet, por pas ca kohe bëhet më e leht.Përserite këtë proces disa here.Nëse keni ndonjë koment, kritike ose   vetëm don të kemi një bised rreth OO atëher me kontakto në rrjetet sociale.Github",
            "content_html": "<p>E pyeta një të afërm timin pse duhet ti mësojmë SOLID principet?Ja si përgjigjet ai…</p><blockquote>  <p>Dallimi në mes amaterëve dhe profesinistëve që kërkohen nga cdo kompani, perfshir: Tesla, Google, Apple, SpaceX etj gjendet tek aplikimi i principeve të ndryshme.</p></blockquote><p>Pasi të lexoni këtë artikull, si dhe të analizoni shembujt që janë në këtë artikull, ju do të kuptoni principet SOLID dhe do të jeni të gatshëm ti aplikoni ato.</p><p>Çdo kompani në Gjermani që do të aplikoni si zhvillues softveri, do të ju parashtrojn pytje në intervistë në lidhje me principet SOLID.</p><p>Principet SOLID në OO programim do të ndihmojnë shumë në karrierën tuaj si programer.Do të kesh një bazë stabile për të ecur përpara, pa pasur parasysh produktin që ti e ndërton.</p><h3 id=\"prezantimi-i-problemit\">Prezantimi i problemit</h3><p>Para se të fillojm, do ta prezantoj problemin që do të punoj gjatë të gjithë shembujve që i marr.</p><h3 id=\"problemi\">Problemi</h3><p>Të marrim shembull një klient i juaj do të ju kërkoj me zhvillu një aplikacion. Ky aplikacion do ti digjitalizoj porosit në restaurantin e tij <em>Villa Natyra</em> që vetëm bën piza dhe hamburgera.Ne si programera të mirë që jem ja ndërtojm aplikacionin, tash ai po e përdor dhe është i kënaqur.</p><p>Në rregull, masi e kem ndërtu produktin tash hajde të flasim për principet.</p><h3 id=\"principi-i-parë---një-klasë-një-përgjegjësi\">Principi i parë - Një klasë, një përgjegjësi</h3><blockquote>  <p>Një klasë duhet të këtë vetëm një përgjegjësi dhe një arsyje të ndryshoj.</p></blockquote><p>Një shembull ku ky princip nuk respektohet</p><pre><code class=\"language-PHP\">class Hamburgeri{   private string $kategoria;   private array $shtesat;   private string $llojiIMishit;    public function __constructor(string $llojiIMishit, array $shtesat)   {       $this-&gt;kategoria = $this-&gt;percaktoKategorine($llojiIMishit);       $this-&gt;shtesat = $shtesat;       $this-&gt;llojiIMishit = $llojiIMishit;   }    private function përcaktoKategorine(string $llojiIMishit): string   {       if (in_array($llojiIMishit, ['file_pule', 'mish_lope'])) {           return 'zgare';       }        return 'furre';   }    public function llogaritShumen(): double   {       double $shuma = 0;       foreach($this-&gt;shtesat as $shtesa) {           $shuma += $shtesa-&gt;merrQmimin();       }        return $this-&gt;llojiIMishit + $shuma;   }    public function ruajFakturen(): void   {       //ktu ruhet faktura në databazë   }}</code></pre><p>Nëse e kemi një klasë vetëm për hamburgerin edhe kjo klasë pranon shtesa sikur sallatë, domate etj.Gjithashtu e përcaktojmë kategorinë mbrenda klasës, i ruajm të dhënat në databazë dhe e kalkulojmë shumën.Atëher kjo klasë do të ndryshoj sa herë që mënyra e ruajtjës në databazë ose mënyra e kalkulimit ose mënyra e përcaktimit të kategorise ndryshojnë.</p><pre><code class=\"language-PHP\">interface Ushqim {} class Hamburgeri implements Ushqim{   private const KATEGORIA = 'furre';   public array $shtesat;   public string $llojiIMishit;   public double $shuma;    public function __constructor(string $llojiIMishit, array $shtesat)   {       $this-&gt;kategoria = $this-&gt;percaktoKategorine($llojiIMishit);       $this-&gt;shtesat = $shtesat;       $this-&gt;llojiIMishit = $llojiIMishit;   }    public function merrKategorine(): string   {       return self::KATEGORIA;   }} class KalkulatoriUshqimit{   public function __constructor(Ushqim $ushqimi){}    public function merrShumen(): double   {       return 0.0; //ktu  kalkulohet shuma.   }} class RuajtjaFaktures{   public function ruaj(Faktura $faktura): void   {       $this-&gt;save($faktura);   }} class Faktura{   public function __constructor(Ushqim $ushqimi, double $shuma)}</code></pre><p>Kurse këtu siç edhe shihet që i kemi ndarë klasat me përgjegjësi të ndryshme, sa herë që kalkulimi i çmimit ndryshon atëher klasa <code class=\"language-plaintext highlighter-rouge\">KalkulatoriUshqimit</code> po ashtu ndryshon. Nëse vendosim ta ndrrojmë mënyrën se si i ruajmë të dhënat atëher klasa <code class=\"language-plaintext highlighter-rouge\">RuajtjaFaktures</code> ndryshon.</p><h3 id=\"principi-i-dytë---e-hapur-për-zgjatje-e-mbyllur-për-ndryshime\">Principi i dytë - E hapur për zgjatje, e mbyllur për ndryshime.</h3><blockquote>  <p>Një klasë duhet të jete e mbyllur për ndryshime ndërsa e hapur për zgjatje.</p></blockquote><p>Ta marrim shembull klasën që i bën kalkulimet <code class=\"language-plaintext highlighter-rouge\">KalkulatoriUshqimit</code> dhe ta shohim si do të ndryshoj nëse një kërkes e re na vjen, shembull “Po me duhet që për studente çmimi final të dal 20% më lirë”</p><p>Tash na si programera pa dijeni për këtë princip “E mbyllur për ndryshime” do ta bëjme një ndryshim si në vijim</p><pre><code class=\"language-PHP\">interface Ushqim {} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           $shuma += $shtesa-&gt;merrShumen();       }        return $shuma;   }    public function merrShumenPerStudente(Ushqim $ushqim): double   {       $shuma = $this-&gt;merrShumen($ushqim);        return $shuma - ($shuma * 0.2);   } }</code></pre><p>Nëse bëjme diçka si kjo atëher së pari klasa ka jo një arsye por dy për të ndryshuar, që e then edhe principin e parë, shohim që po e kalkulon shumën e ushqimit dhe zbritjen për studenta. Tash nëse ndryshon mënyra e kalkulimit të ushqimit ose përqindja për studenta, atëher kjo klasë duhet të modifikohet.</p><p>Nëse e konsiderojm Principin e parë, zbritja duhet të jete në një klas ndamas dhe në bazë të principit të dytë, klasa e re mund ta përdor klasën që kalkulon por nuk duhet ta ndryshoj atë.</p><p>Si rezultat kemi bërë një ndryshim si në vijim.</p><pre><code class=\"language-PHP\">interface Ushqim {} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           $shuma += $shtesa-&gt;merrShumen();       }        return $shuma;   } } class KalkulatoriUshqimitPerStudente extends KalkulatoriUshqimit{   private const ZBRITJE_NE_PERQINDJE = 0.2;    public function merrShumen(Ushqim $ushqimi): double   {       return $this-&gt;zbritShumen(parent::merrShumen($ushqimi));   }    private function zbritShumen(double $shuma): double   {       return $shuma - ($shuma * self::ZBRITJE_NE_PERQINDJE);   } }</code></pre><p>Siç edhe pe shihni i kemi ndarë përgjegjsit në klasa të ndryshme, tash nëse mënyra e kalkulimit të ushqimit ndryshon atëher do të ndryshoj vetem <code class=\"language-plaintext highlighter-rouge\">KalkulatoriUshqimit</code> dhe nëse zbritja për student ndryshon atëher do të ndryshoj vetëm klasa <code class=\"language-plaintext highlighter-rouge\">KalkulatoriUshqimitPerStudente</code>.</p><h3 id=\"principi-i-tretë---zëvendesimi-liskov\">Principi i tretë - Zëvendesimi Liskov</h3><blockquote>  <p>Ky princip thot që nëse funksioni f(x) punon me objektet e tipit T. Atëher funksioni f(y) duhet të punoj me objektet y të tipit S ku S është nën tip i T.</p></blockquote><p>Ndoshta shembulli që e then këtë princip do ta lehtsoj kuptimin e ketij principi.</p><pre><code class=\"language-PHP\">interface Ushqim {} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           $shuma += $shtesa-&gt;merrShumen();       }        return $shuma;   } } class KalkulatoriUshqimitPerStudente extends KalkulatoriUshqimit{   private const ZBRITJE_NE_PERQINDJE = 0.2;    public function merrShumen(Ushqim $ushqimi): double   {       return $this-&gt;zbritShumen(parent::merrShumen($ushqimi));   }    private function zbritShumen(double $shuma): double   {       return $shuma - ($shuma * self::ZBRITJE_NE_PERQINDJE);   } }</code></pre><p>Kjo pjese e kodit është pjesë e principit të dytë ku e kem zgjatur klasën <code class=\"language-plaintext highlighter-rouge\">KalkulatoriUshqimit</code>, me këtë ndryshim të metodës <code class=\"language-plaintext highlighter-rouge\">merrShumen</code> e kemi thyer rregullin e principit të tretë.Nëse i referohemi definicionit i bjen që e njëjta metodë nuk duhet të kthen vlera të ndryshme edhe pse është klasë tjeter.</p><p>Do ta rregullojme këtë klasë si në vijim.</p><pre><code class=\"language-PHP\">interface Ushqim {} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           $shuma += $shtesa-&gt;merrShumen();       }        return $shuma;   } } class KalkulatoriUshqimitPerStudente extends KalkulatoriUshqimit{   private const ZBRITJE_NE_PERQINDJE = 0.2;    public function merrShumenEZbritur(): double   {       $this-&gt;zbritShumen($this-&gt;merrShumen());   }    private function zbritShumen(double $shuma): double   {       return $shuma - ($shuma * self::ZBRITJE_NE_PERQINDJE);   } }</code></pre><p>Në vend që ta modifikojm metodën e klasës origjinale, do ta përdorim atë në klasën për studente dhe do të shtojmë metoda në klasën për studente.</p><h3 id=\"principi-i-katert---ndarja-e-kontratave\">Principi i katert - Ndarja e kontratave</h3><blockquote>  <p>Një klasë nuk duhet ta implementoj një metodë që nuk i nëvojitet.</p></blockquote><p>Shembull shtesat e ushqimeve, siq e kemi parë me lartë secila shtesë e ka çmimin e vet, po çka nëse kemi shtesa që nuk kushtojn?Shembull:</p><pre><code class=\"language-PHP\">interface Ushqim {}interface Shtesa {   public function merrShumen(): double;} class Sallate implements Shtesa {   public const QMIMI = 0.50;    public function merrShumen() {       return self::QMIMI;   }} class BbqSos implements Shtesa {   public const QMIMI = 0.20;    public function merrShumen() {       return self::QMIMI;   }} class Ketchup implements Shtesa {   public const QMIMI = 0.00;    public function merrShumen() {       return self::QMIMI;   }} class Hamburger implements Ushqim {   private const QMIMI = 2.00;    public function merrQmimin():double   {       return self::QMIMI;   }}</code></pre><p>Siç e shohim në shembullin më lart, shtesa  <code class=\"language-plaintext highlighter-rouge\">Ketchup</code> edhe pse është falas  duhet ta implementoj metodën <code class=\"language-plaintext highlighter-rouge\">merrShumen</code> dhe kjo nuk e respekton principin e katërt, një klasë nuk duhet ta implementoj një metodë që nuk i nevojitet.</p><p>Kështu duhet  ta ndryshojm kodin që ta respektojme principin e katërt.</p><pre><code class=\"language-PHP\">interface Ushqim {}interface Shtesa {   public function merrSasine(): int;}interface ShtesaMePages implements Shtesa {   public function merrShumen(): double;} class Sallate implements ShtesaMePages {   public const QMIMI = 0.50;    public function merrShumen() {       return self::QMIMI;   }} class Ketchup implements Shtesa {   private int $sasia = 1;    public function merrSasine(): int   {       return $this-&gt;sasia;   }} class Hamburger implements Ushqim {   private const QMIMI = 2.00;    public function merrQmimin():double   {       return self::QMIMI;   }} class KalkulatoriUshqimit{   public function merrShumen(Ushqim $ushqim): double   {       $shuma = $ushqimi-&gt;merrLlojinEMishit()-&gt;merrShumen();       foreach($ushqimi-&gt;merrShtesat() as $shtesa) {           if ($shtesa instanceof ShtesaMePages) {               $shuma += $shtesa-&gt;merrShumen();             }       }        return $shuma;   } }</code></pre><p>Ky është një shembull ku ndahet kontrata për shtesat me  çmime dhe ato pa  çmime, për arsye që shtesat pa çmime nuk kan nevoj ta implementojnë metodën <code class=\"language-plaintext highlighter-rouge\">merrQmimin()</code>.</p><h3 id=\"principi-i-pestë---inversioni-i-varësisë\">Principi i pestë - Inversioni i varësisë</h3><blockquote>  <p>Një klasë që kryen një punë asnjëherë nuk duhet të varet në mjetin që e përdor por në kontratë.</p></blockquote><p>Një shembull do të ishte ta ruajm fakturen në MySQL databazë si në shembullin në vijim.E mbani mend si klasa <code class=\"language-plaintext highlighter-rouge\">RuajtjaFaktures</code> varet direkt në klasën <code class=\"language-plaintext highlighter-rouge\">Databaza</code> që është edhe implementimi mbrenda.Tani klasa <code class=\"language-plaintext highlighter-rouge\">RuajtjaFaktures</code> e then principin e parë sepse nëse e ndryshojme databazën  atëher duhet ta ndryshojm edhe klasën <code class=\"language-plaintext highlighter-rouge\">RuajtjaFaktures</code>.</p><pre><code class=\"language-PHP\">class Databaza{   public function ruaj(Faktura $faktura): void   {       $sql = \"INSERT into FAKTURAT (val1, val2, val3) VALUES (1,2,3);\"       $this-&gt;db-&gt;executeSql($sql);   }} class RuajtjaFaktures{   public function __constructor(Databaza $databaza){}    public function ruaj(Faktura $faktura): void   {       $this-&gt;databaza-&gt;ruaj($faktura);   }} class Faktura{   public function __constructor(Ushqim $ushqimi, double $shuma)}</code></pre><p>Një shembull  që do ta respektonte principin e pestë do të ishte si në vijim.</p><pre><code class=\"language-PHP\">interface Databaza {   public function ruaj(Faktura $faktura): void;} class HapsiraRuajtjesSeFakturave implements Databaza{   public function ruaj(Faktura $faktura): void   {       $sql = \"INSERT into FAKTURAT (val1, val2, val3) VALUES (1,2,3);\"       $this-&gt;db-&gt;executeSql($sql);   }} class RuajtjaFaktures{   public function __constructor(Databaza $databaza){}    public function ruaj(Faktura $faktura): void   {       $this-&gt;databaza-&gt;ruaj($faktura);   }}   class Faktura{   public function __constructor(Ushqim $ushqimi, double $shuma)}</code></pre><p>Ne këtë shembull e shohim që tani kemi një kontratë <code class=\"language-plaintext highlighter-rouge\">Databaza</code> dhe një klasë ku gjendet implementimi i ruajtjes së fakturave <code class=\"language-plaintext highlighter-rouge\">HapsiraRuajtjesSeFakturave</code>, tash nëse vendosim ta ndryshojm databazën në MongoDB, NoSQL ose çkado qoft nuk kemi nevoj ta ndryshojm klasën <code class=\"language-plaintext highlighter-rouge\">RuajtjaFaktures</code> sepse ajo varet në kontrat e jo në implementim.</p><h3 id=\"finalizimi-dhe-hapat-e-tjerë\">Finalizimi dhe hapat e tjerë</h3><p>Këto janë pra pesë principet në OO të cilat shikohen në secilën intervistë se sa mirë i ke kuptuar dhe a din si ti përdorni ato.Hapat e radhës janë: Që të provosh ti aplikosh këto principe duhet startuar një projekt të vogël ose edhe në punën ku punon.Kur e shikon një kod në fillim të merr kohe ti shikosh të gjitha principet, por pas ca kohe bëhet më e leht.Përserite këtë proces disa here.</p><p>Nëse keni ndonjë koment, kritike ose   vetëm don të kemi një bised rreth OO atëher me kontakto në rrjetet sociale.<a href=\"https://github.com/diarselimi\">Github</a></p>",
            "url": "https://programeret.github.io/2021/11/17/solid-principet-dhe-si-ti-aplikoni-ne-kod",
            
            
            
            "tags": ["SOLID,","OO,","PHP,","PROGRAMERAT"],
            
            "date_published": "2021-11-17T09:15:20+01:00",
            "date_modified": "2021-11-17T09:15:20+01:00",
            
                "author": "Diar Selimi"
            
        }
    
    ]
}